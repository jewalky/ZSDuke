class DukeShadowSprite : Actor
{
    Default
    {
        Radius 0;
        Height 0;
    
        +NOINTERACTION;
        
        RenderStyle "Stencil";
        StencilColor "00 00 00";
    }
    
    override void Tick()
    {
        if (!master)
        {
            // die
            Destroy();
            return;
        }
        
        if (!master.bFloorClip)
        {
            vector3 offsets = (0,0,0);
            // note: this is a hack. gross hack. it works, except portals. in portals the shadow will still be random.
            Actor consoleCamera = (consoleplayer>=0) ? players[consoleplayer].camera : null;
            if (consoleCamera)
            {
                vector3 awayFromCamera = (pos-consoleCamera.pos).Unit()/8;
                offsets = awayFromCamera;
            }
            
            A_Warp(AAPTR_MASTER, offsets.x, offsets.y, offsets.z, 0, WARPF_ABSOLUTEOFFSET|WARPF_NOCHECKPOSITION|WARPF_TOFLOOR|WARPF_WARPINTERPOLATION|WARPF_COPYVELOCITY);
            
            sprite = master.sprite;
            frame = master.frame;
            A_SetScale(master.scale.x, master.scale.y/16);
            alpha = master.alpha/2;
            angle = master.angle;
            A_SetSize(master.radius, 0, false);
        }
        else
        {
            alpha = 0;
        }
            
        Super.Tick();
        
    }
    
    States
    {
    Spawn:
        TNT1 A 1;
        loop;
    }
}

class DukeMonster : Actor
{
	void A_ThrowGibs(class<DNGibs> cls = "DNGibs", bool down = false)
	{
		for (int i = 0; i < 16; i++)
		{
			//
			Actor gibs = Spawn(cls, pos);
			gibs.vel = (frandom(-8,8), frandom(-8,8), frandom(0,down?-1:16));
		}
	}
    
    Actor shadowSprite;
    
    override void PostBeginPlay()
    {
        Super.PostBeginPlay();
        shadowSprite = Spawn("DukeShadowSprite", pos);
        shadowSprite.alpha = 0; // for the first tick only
        shadowSprite.master = self;
    }
    
	bool CheckShrunk()
	{
		return (!!FindInventory("Shrunk"));
	}
    
    double GetGroundHeight()
    {
        double _floorz = GetZAt();
        bool ok; Actor pOnmobj;
        [ok, pOnmobj] = TestMobjZ(true);
        if (!pOnmobj) return _floorz;
        double _actorz = pOnmobj.pos.z+pOnmobj.height;
        return max(_floorz, _actorz);
    }
    
    bool CheckOnGround()
    {
        return (abs(GetGroundHeight()-pos.z) < 1);
    }
	
	Default
	{
		+NOINFIGHTING;
	}
}

class CacoWithShadow : Cacodemon replaces Cacodemon
{
    States
    {
    Spawn:
        TNT1 A 0 A_Jump(256, "SpawnReal");
        TNT1 A 0 A_SpawnItemEx("DukeShadowSprite", 0, 0, 0, 0, 0, 0, 0, SXF_SETMASTER);
    SpawnReal:
        goto Super::Spawn;
    }
}